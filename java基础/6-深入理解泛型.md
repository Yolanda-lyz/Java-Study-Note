### 1. 泛型基础

在使用泛型之前，如果要你实现一个通用的，可以处理不同类型数据的类，那么我们会使用对象的公共父类Object来实现：

```java
public class Cache {
    Object value;
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}
```

这样，Cache类就可以存取任意类型的数据。只要不发生类型强转异常即可。

```java
Cache cache = new Cache();
cache.setValue(134);
int value = (int) cache.getValue();
cache.setValue("hello");
String value1 = (String) cache.getValue();
```

而改写为泛型的形式，会把value属性的类型参数化，外部调用时需传入该参数：

```java
public class Cache<T> {
    T value;
    public T getValue() {
        return value;
    }
    public void setValue(T value) {
        this.value = value;
    }
}
```

泛型Cache使用时，需要把类型作为参数传入，之后也不需对``getValue()``返回值进行类型强转了。

```java
Cache<Integer> cache1 = new Cache<Integer>();
cache.setValue(134);
int value =  cache.getValue();

Cache<String> cache2 = new Cache<String>();
cache.setValue("hello");
String value1 = (String) cache.getValue();
```

对比以上两种方式，可以得出：

- 使用Object来实现时，所有的参数、返回值类型都是Object，每次使用都需要执行类型强转。而且编译器也无法得知类型转换是否正确，只有在运行时才知道，程序极不安全。
- 而使用泛型来实现时，一旦类型确定，编译器就能明确所有``T``位置的类型，不再需要执行类型强转。且如果出现类型不匹配，就会编译不通过，比如，无法执行``cache1.setValue("abc");``，它只接受类型为Integer的参数。

所以，我们可以概括出泛型的几个特点：

- 泛型把类的数据类型参数化了，使得它们可以从外部传入，从而扩展了类处理数据的范围。
- 当类型确定后，泛型会对类型进行检测，若不符合类型，则编译不通过；
- 提高代码的可读性，不需等到运行时才做强制转换。在定义或实例化时就能明确操作的数据类型。

### 2. 泛型的使用

泛型可以应用在类、接口和方法中。

#### 2.1 泛型类

``<T>``可理解为类型参数声明，T代表类型参数，用于指代任何类型。

```java
public class testGenerics<T> {
    private T value;
    public testGenerics(T v) {
        value = v;
    }
}
//泛型类还可以接受多个类型参数
public class testGenerics<T, E> {
    private T value;
    private E element;
    public testGenerics(T v, E e) {
        value = v;
        element = e;
    }
}
```

T其实是一个形参，实际可以用其他字符代替，只是出于编码规范，java建议我们用单个大写字母来代表类型参数。常见的有：

- T：Type，一般代表任何类；
- E：Element，一般代表元素类型，或者Exception代表异常；
- K：Key，key值类型；
- V：Value，value值类型，一般与K搭配使用；
- S：Subtype，子类型。

使用泛型类创建实例时，只需在尖括号中声明相应的类型，T，E等类型参数就会被替换成对应的类型。

#### 2.2 泛型接口

泛型接口的使用与泛型类基本相同：

```java
public interface Comparator<T> {
    public int compare(T lhs, T rhs);
    public boolean equals(Object object);
}
```

实现接口时，指明具体的类型：

```java
public class StringCompare implements Comparator<String> {
    @Override
    public int compare(String lhs, String rhs) {
        ......
    }
}
```

#### 2.3 泛型方法

如果泛型方法所在的类是个泛型类，且方法处理的数据类型也与泛型类所声明的类型相同，则直接使用类声明的参数即可。

```java
public class testGenerics<T> {
    private T value;
    public testGenerics(T v) {
        value = v;
    }
    
    public T compare(T a, T b) {
        ......
    }
}
```

如果在非泛型类中或方法需要处理的数据类型不同于泛型类声明的类型时，就需要自己声明类型。定义泛型方法时，必须在返回值前面加一个``<T>``（T也可以由其他字符代替），来声明这是一个泛型方法。

```java 
public class testGenerics<T> {
    public <E> E compare(E a, E b) {
        ......
    }
    public <E> T compare(T a, T b) { //这种写法则与没有<E>声明无区别，编译时仍会把T替代成指定的类型
        ......
    }
}
```

泛型方法中的类型参数与泛型类是没有联系的，泛型方法的类型是在运行时确定的，且由于``E``并没有像泛型类一样通过传参指定，所以在调用泛型方法时，虽然形参可能都声明为类型E，但实际上实参的类型可以不同，参数类型并没有关联。

```java
public class testGenerics<T> {
    public <E> E compare(E a, E b) {
        ......
    }
}
testGenerics<Integer> g = new testGenerics<Integer>();
g.compare("abc", "abc");
g.compare("abc", 1);//虽然两个参数都声明为类型E，但实际上并没有关联，可以传入两个类型不同的参数
```

### 3. 泛型的通配符

#### 3.1 无限制通配符\<?>

表示可以持有任何类型，当不确定或不关心实际要操作的类型时，可以使用。？与Object不同，List\<?>表示未知类型的列表，而List<Object>表示一个Object类型的列表。

``<?>``删减了``增改``的写功能，只保留了与具体类型无关的``读与删``功能，像增加或修改具体类型元素的语句是无法编译通过的。比如``List<?>``，即使我们增加或修改的元素仍保证与容器当前装载元素类型相同，也无法编译通过。

```java
public void setList(List<?> list) {
    if(list.get(0) != null && list.get(1) != null) {
        list.add(list.get(0));//编译不通过
        list.set(0, list.get(1));//编译不通过
    }
    if(list.size() > 0) {
        list.remove(0);//与类型无关的写操作则可以执行
    }
}
```

#### 3.2 上界通配符 <? extends E>

表示泛型中的参数必须是E或E的子类，如果传入的类型不是E或者E的子类，则编译不成功，且泛型中可以使用E的方法。定义了上限，且只有读的能力而不能写。

不能写的原因：父类无法强转子类。比如List的类型为Apple，却要将Fruit强转为Apple放到Apple列表中，当然无法执行。

```java
public void test(List<? extends Fruit> list) {
    list.add(new Fruit()); //编译不通过
}
```

#### 3.3 下界通配符<? super E>

super表示这个泛型的参数必须是E或者E的父类。定义了下限，有读的能力以及部分写的能力，子类可以强转为父类。

```java
public void test(List<? super Fruit> list) {
    list.get(0).read();//编译不通过，因为可能Fruit的父类没有定义read方法
    list.add(new Apple("apple"));
    list.add(new Fruit("fruit"));
}
```



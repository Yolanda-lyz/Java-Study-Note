### 1. 枚举基础

- 从jdk 5.0开始，引入了enum关键字，它与class，interface具有同一级别的特性。枚举类的定义由enum替代class关键字实现。
- 使用enum来定义一个枚举类时，编译器会自动创建一个final类型的类继承于``Enum``抽象类：``public final class T extends Enum``，所以，enum类不能再继承于其他类，它已隐式地继承了Enum类；它也不能再被其他类继承，因为已由final修饰。
- 枚举常量的创建必须放在枚举类中的第一句，其创建方式：``常量名(实参列表)``。
- 枚举类同普通类一样，可以定义属性、构造方法、普通方法、抽象方法等，只是枚举类允许枚举常量自己对抽象方法的特有实现。
- 下面是一个四则运算操作符的枚举类型定义，包含了成员变量、构造方法、抽象方法的定义。ADD、SUB等是枚举类的枚举常量，每个枚举常量都实现了calculate抽象方法。

```java
public enum Operator {
    ADD("+") {
        @Override
        public int calculate(int a, int b) {
            return a + b;
        }
    },
    SUB("-") {
        @Override
        public int calculate(int a, int b) {
            return a - b;
        }
    },
    MUL("*") {
        @Override
        public int calculate(int a, int b) {
            return a * b;
        }
    },
    DIV("/") {
        @Override
        public int calculate(int a, int b) {
            return a / b;
        }
    };

    Operator (String operator) {
        this.operator = operator;
    }

    private String operator;

    public abstract int calculate(int a, int b);

    public String getOperator() {
        return operator;
    }
}
```

### 2. 枚举原理分析

上面的基础介绍中，不知大家有没有注意到这么一句话：``枚举类允许枚举常量自己对抽象方法的特有实现``，四则运算操作符的例子中每个枚举常量也都实现了calculate的抽象方法。重写抽象方法，不应该是类层级的动作吗？这里又是怎么做到的？

--待续

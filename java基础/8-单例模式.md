### 1. 单例模式

单例模式是一种常用的设计模式，使用单例模式的类只能允许一个实例存在，且该实例由该类自己负责创建，并提供一个全局的访问点。

### 2. 单例类特征

1）构造函数声明为private，只能通过该类提供的静态方法来访问唯一实例；

2）须确保单例类的实例有且只有一个，所以在多线程环境下，应慎重考虑单例类实例创建的线程安全性。

### 3. 单例模式的写法及线程安全性分析

#### 3.1 饿汉式

不管用不用，都先创建。使用了static关键字修饰，在类加载过程中就会初始化该实例，在jvm层面上保证了线程安全。若变量从始至终都没有被使用过，则会造成内存的浪费。

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public Singleton getInstance() {
        return instance;
    }
}
```

#### 3.2 懒汉式

顾名思义，比较懒，推迟到第一次使用的时候才初始化。使用时检查是否已初始化，仍未初始化时才创建。

##### 3.2.1 普通懒汉式【非线程安全】

懒汉式的普通写法：使用时先做检查，若为空，则进行初始化。这种写法是非线程安全的，在多线程环境下，这种写法无法保证只生成一个实例：假设A线程在执行instance判空时，B线程在初始化instance，此时，A线程读取到的instance可能未初始化完成，仍为空，所以也会执行instance的初始化逻辑。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}
    
    public static Singleton getInstance() {
        if(instance == null) {           //A线程执行
            instance = new Singleton();  //B线程执行
        }
        return instance;
    }
}
```

##### 3.2.2 同步方法的懒汉式【线程安全】

针对普通懒汉式的线程安全问题，最简单的方法就是直接对getInstance()方法做同步处理。由于同一时刻只允许一个线程调用getInstance()方法，如果getInstance()被多个线程频繁调用，就会导致程序执行性能下降。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}
    
    public synchronized static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

##### 3.2.3 优化同步方法性能的懒汉式【非线程安全】

在同步方法的基础上进行优化，改为双重检查锁定的形式：如果第一次检查instance非空，就不需要执行加锁及初始化操作，从而降低synchronized带来的性能开销。通过加锁来保证同一时刻只有一个线程在创建对象，在创建前会再做一次检查，防止多个线程创建多个实例。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}
    
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

实际上，这种看似完美的写法仍然是非线程安全的！！

instance初始化代码：``instance = new Singleton()``可以拆解为以下的伪代码：

```java
memory = allocate(); //分配对象的内存空间
ctorInstace(memory); //初始化对象
instance = memory; //设置instance指向刚分配的内存地址
```

而java编译器和处理器为优化性能可能对指令进行重排序，2和3重排后的代码执行时序：

```java
memory = allocate(); //分配对象的内存空间
instance = memory; //设置instance指向刚分配的内存地址，而此时对象还没有被初始化
ctorInstace(memory); //初始化对象
```

在这种重排序的情况下，如果线程A已执行了``instance = memory``但还未执行``ctorInstance(memory)``，此时切换到线程B执行第一次检查，instance不为null，接着线程B就会去访问这个实际上还未初始化完成的instance对象，导致产生异常。

##### 3.2.4 优化同步方法性能的懒汉式（双重检查锁）【线程安全】

为解决3.2.3写法的线程安全问题，就要阻止指令重排序的发生，所以将instance声明为volatile型，由volatile的内存语义来阻止重排序的发生。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}
    
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 3.3 静态内部类

```java
public class Singleton {
    private Singleton() {}
    
    private static class InstanceHolder {
        public static Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return InstanceHolder.instance;
    }
}
```

#### 3.4 枚举实现

```java
public enum Singleton {
    INSTANCE;
    private Singleton() {}
}

```


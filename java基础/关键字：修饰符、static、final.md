### 1. public、default、protected、private

- java的默认权限修饰符为default。
- 类的访问修饰符只能为空（即默认default）或public。

| 修饰符    | 同一个类 | 同包中其他类 | 不同包的子类 | 不同包的非子类 | 作用范围   |
| --------- | -------- | ------------ | ------------ | -------------- | ---------- |
| public    | √        | √            | √            | √              | 无限制     |
| protected | √        | √            | √            | ×              | 包内及子类 |
| default   | √        | √            | ×            | ×              | 包内       |
| private   | √        | ×            | ×            | ×              | 类内       |

### 2. static

- import static ...，如``import static java.lang.Math.*;``。
  - 意思是导入Math类的静态成员（静态方法、静态变量），调用时直接使用方法名，而不是类名.方法名的形式。
  - 但这种形式可能导致代码更难以阅读，且如果同时导入的两个类中有重命名的静态成员，会导致编译错误。
- static变量，静态变量。
  - 静态变量属于类，只有一个实例，被类的所有对象所共享，仅在类加载的时候分配一次内存空间。
  - 非静态变量属于类的实例对象，在创建对象时初始化，且各个对象的非静态变量互不影响。
  - 另外，在java中，``static是不允许用来修饰局部变量的``，这属于java语法上的规定。
- static方法，静态方法，
  - 静态方法，也是属于类的，不需要创建对象就可以通过【类名.方法名】的形式调用。
  - 非静态方法则是属于对象的，必须在创建对象之后才能通过【对象.方法名】的方式调用。
  - 因此，静态方法不能调用属于对象的方法和变量，即不能使用this和super关键字，也不能调用非静态的方法和成员变量。
  - 但非静态的方法可以访问静态成员方法和成员变量。
- static代码块，静态代码块，形如``static { ... }``。
  - 一个类中可以有多个静态代码块，可以放置在类中的任何位置（当然不能在方法体内）。
  - 静态代码块主要用于对类静态属性的初始化，在类加载时会按照静态代码块在类中出现的顺序依次执行这些代码块，同样只会执行一次。
- static内部类
  - 静态内部类可以不依赖于外部类实例对象而被实例化，所以静态内部类不能访问外部类的非静态方法和成员变量，只能访问外部类中的静态方法和成员变量。
  - 非静态内部类必须在外部类实例化后才能实例化，这是由于非静态内部类经编译器编译后，会生成一个final修饰的变量this，指向其外部类对象，即``非静态内部类默认持有外部类的引用``。非静态内部类之所以能访问其外部类的方法和变量，就是依靠这个this变量。只有在外部类实例化之后，非静态内部类实例化时才能明确this变量的指向。
  - static修饰类仅局限于内部类，其他普通类则不允许。

> https://www.cnblogs.com/dolphin0520/p/3799052.html

### 3. final

- 修饰类

  final类不能被继承。

- 修饰方法

  方法不可覆盖，即不能被子类重写。类的private方法会隐式地被声明为final。

- 修饰变量

  - 修饰基本数据类型变量：数值一旦初始化之后就不能更改。

  - 修饰引用数据类型变量：一旦被初始化之后便不能修改引用的指向。

  - final修饰的成员变量，必须在定义时初始化，或者使用静态代码块，或者在构造函数或构造代码块中初始化。

  - ``static final修饰``的成员变量，只能在定义时或静态代码块中初始化。因为static成员变量表明其属于类，故不能在属于类对象的构造函数中初始化。

  - final修饰变量，可以在一定程度上实现编译优化。如下示例中，b由final修饰，编译时由于已能明确其值，所以编译器会将其当常量使用，在所有使用到b的地方会直接将变量b替换为它的具体值，即``String d = b + 1;``经编译后为``String d = "abc" + 1;``；在执行加号连接时，编译器会将尽可能多的字符串连接起来，即优化后为``String d = "abc1"``，因此最终``a == d``为true。

    但如果编译时不能明确final修饰的变量的值，则无法进行替换优化，因此``a == f``为false。

    ```java
    public class Test {
        public static void main(String[] args) {
            String a = "abc1";
            final String b = "abc";
            String c = "abc";
            String d = b + 1;
            String e = c + 1;
            final String f = getStr() + 1;
            System.out.println(a == d);  //（1）true
            System.out.println(a == e);  //（2）false
            System.out.println(a == f);  //（3）false
        }
        
        public static String getStr() {
            return "abc";
        }
    }
    ```

  - 匿名内部类中使用的外部局部变量都必须声明为final。

- 修饰参数

  参数不可变，方法的形参被final修饰，则传入的参数在方法内不可被修改。使用final修饰方法参数的目的是防止修改这个参数的值，同时也是一种声明和约定，强调这个参数是不可变的。

### 4. final域的内存语义

待完成
